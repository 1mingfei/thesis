\newpage
\section{Kinetic Monte Carlo Setup}
\label{Chap:Al/Vac:section:KMC}

Most parts of the \ac{KMC} algorithm were implemented following the approach we discussed in Algorithm. \ref{algo:kMC} of Chap. \ref{chap:meth:KMC}. In this implementation, several points are worth noticing: 1) Event list is determined on the fly. We consider the first nearest neighbor exchange of vacancies. This yields a total of 12 times the total number of vacancies possible events. 2) Then, a \ac{NN} potential is used, instead of traditional empirical potentials or analytical equations, to evaluate diffusion barriers. Noting that all the four symmetry equivalent structures are taken into consideration. 3) At each step, both the forward and backward diffusion barriers of executing the current jump will be calculated to obtain the energy change of the current system, via:
\begin{align}
\Delta E = {E_a}^{forward} - {E_a}^{backward}
\label{Chap:Al/Vac:eq:barrier-EDiff}
\end{align}
where $\Delta E$ is the energy difference between initial and final state, ${E_a}^{forward}$ and ${E_a}^{backward}$, are the forward/backward diffusion barrier, respectively. And the overall energy change as time-evolving is cumulated. 4) In order to boost the system out of low-energy barrier trapping states, a local super-basin method is also implemented based on Ref. \cite{fichthorn2013local}.

For the \ac{KMC} simulations, (30x30x30) supercell containing 108,000 atoms were used. 3240 Mg atoms, 1700 Zn atoms and 1 vacancy atom were randomly chosen among 108,000 atoms. This setup corresponds to $\sim$ 3 atom. \% of Mg, $\sim$ 2 atom. \% of Zn and a vacancy concentration of $\sim$ 1e-6. The probability, $p_k$, of selecting an event $k$ is calculated, via:
\begin{subequations}
\begin{align}
& p_i = r_i / R    \label{Chap:Al/Vac:eq:prob} \\
& r_i = \mu_a * exp(- E_a / k_B T)  \label{Chap:Al/Vac:eq:rate} \\
& R = \sum_{j=1}^N r_j \label{Chap:Al/Vac:eq:R} \\
& \sum_{k=1}^{i-1} p_k < rand < \sum_{k=1}^{i} p_k \label{Chap:Al/Vac:eq:choice}
\end{align}
\end{subequations}
where $\mu_a$ is the diffusion pre-exponential factor, $E_a$ is the diffusion barrier, $k_B$ is the Boltzmann constant, T is the temperature, $N$ is the total number of events, and $rand$ is a random number $\in [0, 1)$. In reality, the diffusion pre-exponential factor, AKA the attempt frequency, and the diffusion barrier depend on the specific configuration \cite{osti_323431,van2001first,le2002kinetic} and type of element which the vacancy jumps to\cite{clouet2004nucleation}. We used \ac{NN} to predict the diffusion barrier, $E_a$, based on local environments. However, the attempt frequency, $\mu_a$, was chosen to use a Debye frequency of 1e13 Hz for all the jump pairs, regardless of their species and local environments. Usually, the pre-exponential factor can result in a 10 times difference. This is still tolerable to predict the event accurately, considering that the difference introduced by the exponential term would be much larger.


\begingroup
\begin{figure}[!ht]
  \centering
  \subfigure{\includegraphics[width=0.75\linewidth]{Chap5/plots/scale.eps}}
\caption[Scalability of KNN2 code on Great Lakes HPC.]{Scalability of KNN2 code for 108,000 atoms on Great Lakes HPC from the University of Michigan with 2x 3.0 GHz Intel Xeon Gold 6154 processors and InfiniBand HDR100 networking, capable of 100 Gb/s throughput.}
\label{Chap:Al/Vac:fig:scale}
\end{figure}
\endgroup


The \ac{KMC} code was written in C++17. \cite{Zhang2020KNN2} Our code has two dependent libraries: 1) We used an open-source C++ module called ``keras2cpp'' to read the Keras model trained in python. \cite{Perevozchikov2019} 2) We also applied another open-source numerical library, called Armadillo \cite{sanderson2016armadillo, sanderson2018user}, to do matrix multiplication for rotating current configurations to symmetry equivalent ones. As we mentioned above, all four symmetry equivalent structures needed to be calculated to evaluate diffusion barriers accurately, and both forward and backward diffusion barriers were required. Therefore, a total of 8 calculations were needed for one event. Therefore it becomes important to speed up calculations. We used \ac{MPI} to parallelize our \ac{KMC} simulations. Two parts are benefited significantly from parallelism implementation: 1) building initial neighbor list of every atom; 2) \ac{KMC} events calculation. Note that once the initial neighbor list is built, one can keep updating the neighbor list on the fly. Besides, diffusion barriers and event rates of 12 possible jumping events of one vacancy were distributed to different cores and collected afterward. We tested the scalability of the code, as shown in Fig. \ref{Chap:Al/Vac:fig:scale}. A (30x30x30) supercell containing 108,000 atoms, was used for this testing. Calculations up to 80,000-steps were tested and benchmarked with the usage of different numbers of nodes. For very limited-steps cases, 10,000-steps for example, more cores showed more advantages, as the initial setup of the neighbor list takes a considerable amount of time. As the simulation goes on, the cost of communication between cores does not affect the scalability significantly.


In order to further speed up \ac{KMC} simulations, a \acf{LRU} Cache, which evict least recently used entry, was implemented based on a hashmap and a  doubly-linked list. Similar idea was practiced by Mason et al.\cite{mason2005fast}. They used Zobrist key to distinguish different binary alloy cluster structures. However, this method ignored detail local environments differences. Instead, we used the 27-digits encoding and store them in an array as the key. The long long int datatype of C++ for a 64-bit machine, can store $2^{64} \sim 1e^{19}$ information. 27-digits encoding scheme with Al, Mg, Zn, and Vac can take up to $4^{27} \sim 1e^{16}$. Therefore, we can simply converting an encoding array to a decimal integer and hash on the decimal integer. The hashmap will hold the keys and the address of the nodes of doubly-linked list . And each node of the doubly-linked list will hold the value of the key, which represents the corresponding diffusion barrier. We will remove elements from the bottom of doubly-linked list and add new elements on top of the bottom of doubly-linked list. And when new entry is accessed, it will be moved to the top again, therefore most recently used entries will always be on the top and least used will be at the bottom of the list. However, by now this implementation only support single core calculations. To make \ac{LRU} Cache available for multiple cores, one way is to sync or share several most recent entries every several thousands of numbers of steps.


Another effort we tried to make \ac{KMC} simulation faster is to boost low-energy barrier event by using \acf{LSKMC} described here in ref. \cite{fichthorn2013local}. The algorithm goes as shown in Algorithm. \ref{algo:lskmc}. Even though the initial and final state of the vacancy is not next to each other in \ac{LSKMC} steps, the corresponding energy change can also be calculated based on a DFS method. Because if the \ac{NN} function to predict the barrier is accurate enough, the energy differences along any path the vacancy takes from the initial site to the final site will be the same. We can do DFS to look for a available path and use the energy changes along the way to get the energy change between two states.

\begin{figure}[!htb]
  \centering
  \begin{minipage}{.75\linewidth}
    \begin{algorithm}[H]
      \caption{\acf{LSKMC} Algorithm from  Ref. \cite{fichthorn2013local}}\label{algo:lskmc}
      \begin{algorithmic}[1]
        \State set $epoch = 0$, $step = 0$, $time = 0$
        \While{$epoch < epoch_{Max}$}
        \State {perform a regular \ac{KMC} step, get time increment $t$.}
        \State {$time$ += $t$}
        \If{$t < t_{critical}$} 
            \State {$step$ += 1} 
        \Else 
            \State {$step = 0$} 
        \EndIf
        \If{$step == step_{critical}$} 
            \State {new superbasin is found.} 
            \State {find transient and absorbing states.}
            \State {compute escape time $t_{escape}$ and probability.}
            \State {decide the exiting states.}
            \State {$time$ += $t_{escape}$}
            \State {$step = 0$} 
        \EndIf
        
        \EndWhile
      \end{algorithmic}
    \end{algorithm}
  \end{minipage}
\end{figure}